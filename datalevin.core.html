<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>datalevin.core documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Datalevin</span> <span class="project-version">0.6.16</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="dtlv.html"><div class="inner"><span>Datalevin Command Line Tool</span></div></a></li><li class="depth-1 "><a href="search.html"><div class="inner"><span>Datalevin Search Engine</span></div></a></li><li class="depth-1 "><a href="server.html"><div class="inner"><span>Datalevin Server/Client</span></div></a></li><li class="depth-1 "><a href="upgrade.html"><div class="inner"><span>Datalevin Database Upgrade</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>datalevin</span></div></div></li><li class="depth-2 branch"><a href="datalevin.client.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>client</span></div></a></li><li class="depth-2 branch current"><a href="datalevin.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="datalevin.interpret.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>interpret</span></div></a></li><li class="depth-2"><a href="datalevin.search-utils.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>search-utils</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="datalevin.core.html#var-add"><div class="inner"><span>add</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-add-doc"><div class="inner"><span>add-doc</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-clear"><div class="inner"><span>clear</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-clear-dbi"><div class="inner"><span>clear-dbi</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-clear-docs"><div class="inner"><span>clear-docs</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-close"><div class="inner"><span>close</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-close-db"><div class="inner"><span>close-db</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-close-kv"><div class="inner"><span>close-kv</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-closed-kv.3F"><div class="inner"><span>closed-kv?</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-closed.3F"><div class="inner"><span>closed?</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-commit"><div class="inner"><span>commit</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-conn-from-datoms"><div class="inner"><span>conn-from-datoms</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-conn-from-db"><div class="inner"><span>conn-from-db</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-conn.3F"><div class="inner"><span>conn?</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-copy"><div class="inner"><span>copy</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-create-conn"><div class="inner"><span>create-conn</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-datom"><div class="inner"><span>datom</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-datom-a"><div class="inner"><span>datom-a</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-datom-e"><div class="inner"><span>datom-e</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-datom-v"><div class="inner"><span>datom-v</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-datom.3F"><div class="inner"><span>datom?</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-datoms"><div class="inner"><span>datoms</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-db"><div class="inner"><span>db</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-db.3F"><div class="inner"><span>db?</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-dir"><div class="inner"><span>dir</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-doc-count"><div class="inner"><span>doc-count</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-doc-indexed.3F"><div class="inner"><span>doc-indexed?</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-doc-refs"><div class="inner"><span>doc-refs</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-drop-dbi"><div class="inner"><span>drop-dbi</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-empty-db"><div class="inner"><span>empty-db</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-entid"><div class="inner"><span>entid</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-entity"><div class="inner"><span>entity</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-entity-db"><div class="inner"><span>entity-db</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-entries"><div class="inner"><span>entries</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-get-conn"><div class="inner"><span>get-conn</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-get-first"><div class="inner"><span>get-first</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-get-range"><div class="inner"><span>get-range</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-get-some"><div class="inner"><span>get-some</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-get-value"><div class="inner"><span>get-value</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-hexify-string"><div class="inner"><span>hexify-string</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-index-range"><div class="inner"><span>index-range</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-init-db"><div class="inner"><span>init-db</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-k"><div class="inner"><span>k</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-list-dbis"><div class="inner"><span>list-dbis</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-listen.21"><div class="inner"><span>listen!</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-new-search-engine"><div class="inner"><span>new-search-engine</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-open-dbi"><div class="inner"><span>open-dbi</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-open-kv"><div class="inner"><span>open-kv</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-opts"><div class="inner"><span>opts</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-pull"><div class="inner"><span>pull</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-pull-many"><div class="inner"><span>pull-many</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-put-buffer"><div class="inner"><span>put-buffer</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-q"><div class="inner"><span>q</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-range-count"><div class="inner"><span>range-count</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-range-filter"><div class="inner"><span>range-filter</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-range-filter-count"><div class="inner"><span>range-filter-count</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-read-buffer"><div class="inner"><span>read-buffer</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-remove-doc"><div class="inner"><span>remove-doc</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-reset-conn.21"><div class="inner"><span>reset-conn!</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-resolve-tempid"><div class="inner"><span>resolve-tempid</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-retract"><div class="inner"><span>retract</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-rseek-datoms"><div class="inner"><span>rseek-datoms</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-schema"><div class="inner"><span>schema</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-search"><div class="inner"><span>search</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-search-index-writer"><div class="inner"><span>search-index-writer</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-seek-datoms"><div class="inner"><span>seek-datoms</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-stat"><div class="inner"><span>stat</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-tempid"><div class="inner"><span>tempid</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-touch"><div class="inner"><span>touch</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-transact"><div class="inner"><span>transact</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-transact.21"><div class="inner"><span>transact!</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-transact-async"><div class="inner"><span>transact-async</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-transact-kv"><div class="inner"><span>transact-kv</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-unhexify-string"><div class="inner"><span>unhexify-string</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-unlisten.21"><div class="inner"><span>unlisten!</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-update-schema"><div class="inner"><span>update-schema</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-v"><div class="inner"><span>v</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-visit"><div class="inner"><span>visit</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-with-conn"><div class="inner"><span>with-conn</span></div></a></li><li class="depth-1"><a href="datalevin.core.html#var-write"><div class="inner"><span>write</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">datalevin.core</h1><div class="doc"><div class="markdown"><p>User facing API for Datalevin library features</p></div></div><div class="public anchor" id="var-add"><h3>add</h3><div class="usage"><code>(add ent attr value)</code></div><div class="doc"><div class="markdown"><p>Add an attribute value to an entity of a Datalog database</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L95">view source</a></div></div><div class="public anchor" id="var-add-doc"><h3>add-doc</h3><div class="usage"><code>(add-doc engine doc-ref doc-text)</code></div><div class="doc"><div class="markdown"><p>Add a document to the search engine, <code>doc-ref</code> can be arbitrary Clojure data that uniquely refers to the document in the system. <code>doc-text</code> is the content of the document as a string. The search engine does not store the original text, and assumes that caller can retrieve them by <code>doc-ref</code>. This function is for online update of search engine index. Search index is updated with the new text if the <code>doc-ref</code> already exists. For index creation of bulk data, use <code>search-index-writer</code>.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L1356">view source</a></div></div><div class="public anchor" id="var-clear"><h3>clear</h3><div class="usage"><code>(clear conn)</code></div><div class="doc"><div class="markdown"><p>Close the Datalog database, then clear all data, including schema.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L1313">view source</a></div></div><div class="public anchor" id="var-clear-dbi"><h3>clear-dbi</h3><div class="usage"><code>(clear-dbi db dbi-name)</code></div><div class="doc"><div class="markdown"><p>Clear data in the DBI (i.e sub-database) of the key-value store, but leave it open</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L970">view source</a></div></div><div class="public anchor" id="var-clear-docs"><h3>clear-docs</h3><div class="usage"><code>(clear-docs engine)</code></div><div class="doc"><div class="markdown"><p>Remove all documents from the search engine index. It is useful because rebuilding search index may be faster than updating some documents.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L1371">view source</a></div></div><div class="public anchor" id="var-close"><h3>close</h3><div class="usage"><code>(close conn)</code></div><div class="doc"><div class="markdown"><p>Close the connection to a Datalog db</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L507">view source</a></div></div><div class="public anchor" id="var-close-db"><h3>close-db</h3><div class="usage"><code>(close-db db)</code></div><div class="doc"><div class="markdown"><p>Close the Datalog database</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L269">view source</a></div></div><div class="public anchor" id="var-close-kv"><h3>close-kv</h3><div class="usage"><code>(close-kv db)</code></div><div class="doc"><div class="markdown"><p>Close this key-value store</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L945">view source</a></div></div><div class="public anchor" id="var-closed-kv.3F"><h3>closed-kv?</h3><div class="usage"><code>(closed-kv? db)</code></div><div class="doc"><div class="markdown"><p>Return true if this key-value store is closed</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L949">view source</a></div></div><div class="public anchor" id="var-closed.3F"><h3>closed?</h3><div class="usage"><code>(closed? conn)</code></div><div class="doc"><div class="markdown"><p>Return true when the underlying Datalog DB is closed or when <code>conn</code> is nil or contains nil</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L514">view source</a></div></div><div class="public anchor" id="var-commit"><h3>commit</h3><div class="usage"><code>(commit writer)</code></div><div class="doc"><div class="markdown"><p>Commit writes to search index, must be called after writing all documents.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L1432">view source</a></div></div><div class="public anchor" id="var-conn-from-datoms"><h3>conn-from-datoms</h3><div class="usage"><code>(conn-from-datoms datoms)</code><code>(conn-from-datoms datoms dir)</code><code>(conn-from-datoms datoms dir schema)</code><code>(conn-from-datoms datoms dir schema opts)</code></div><div class="doc"><div class="markdown"><p>Create a mutable reference to a Datalog database with the given datoms added to it. <code>dir</code> could be a local directory path or a dtlv connection URI string.</p>
<p><code>opts</code> map has keys:</p>
<ul>
  <li>
  <p><code>:validate-data?</code>, a boolean, instructing the system to validate data type during transaction. Default is <code>false</code>.</p></li>
  <li>
  <p><code>:auto-entity-time?</code>, a boolean indicating whether to maintain <code>:db/created-at</code> and <code>:db/updated-at</code> values for each entity. Default is <code>false</code>.</p></li>
  <li>
  <p><code>:search-opts</code>, an option map that will be passed to the built-in full-text search engine</p></li>
  <li>
  <p><code>:kv-opts</code>, an option map that will be passed to the underlying kV store</p></li>
</ul></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L446">view source</a></div></div><div class="public anchor" id="var-conn-from-db"><h3>conn-from-db</h3><div class="usage"><code>(conn-from-db db)</code></div><div class="doc"><div class="markdown"><p>Creates a mutable reference to a given Datalog database. See <a href="datalevin.core.html#var-create-conn">create-conn</a>.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L440">view source</a></div></div><div class="public anchor" id="var-conn.3F"><h3>conn?</h3><div class="usage"><code>(conn? conn)</code></div><div class="doc"><div class="markdown"><p>Returns <code>true</code> if this is an open connection to a local Datalog db, <code>false</code> otherwise.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L432">view source</a></div></div><div class="public anchor" id="var-copy"><h3>copy</h3><div class="usage"><code>(copy db dest)</code><code>(copy db dest compact?)</code></div><div class="doc"><div class="markdown"><p>Copy a Datalog or key-value database to a destination directory path, optionally compact while copying, default not compact. </p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L982">view source</a></div></div><div class="public anchor" id="var-create-conn"><h3>create-conn</h3><div class="usage"><code>(create-conn)</code><code>(create-conn dir)</code><code>(create-conn dir schema)</code><code>(create-conn dir schema opts)</code></div><div class="doc"><div class="markdown"><p>Creates a mutable reference (a “connection”) to a Datalog database at the given location and opens the database. Creates the database if it doesn’t exist yet. Update the schema if one is given. Return the connection. <code>dir</code> could be a local directory path or a dtlv connection URI string.</p>
<p><code>opts</code> map may have keys:</p>
<ul>
  <li>
  <p><code>:validate-data?</code>, a boolean, instructing the system to validate data type during transaction. Default is <code>false</code>.</p></li>
  <li>
  <p><code>:auto-entity-time?</code>, a boolean indicating whether to maintain <code>:db/created-at</code> and <code>:db/updated-at</code> values for each entity. Default is <code>false</code>.</p></li>
  <li>
  <p><code>:search-opts</code>, an option map that will be passed to the built-in full-text search engine</p></li>
  <li>
  <p><code>:kv-opts</code>, an option map that will be passed to the underlying kV store</p></li>
</ul>
<p>Please note that the connection should be managed like a stateful resource. Application should hold on to the same connection rather than opening multiple connections to the same database in the same process.</p>
<p>Connections are lightweight in-memory structures (~atoms). See also <a href="datalevin.core.html#var-transact.21">transact!</a>, <a href="datalevin.core.html#var-db">db</a>, <a href="datalevin.core.html#var-close">close</a>, <a href="datalevin.core.html#var-get-conn">get-conn</a>, and <a href="datalevin.core.html#var-open-kv">open-kv</a>.</p>
<p>To access underlying DB, deref: <code>@conn</code>.</p>
<p>Usage:</p>
<pre><code>       (create-conn)

       (create-conn "/tmp/test-create-conn")

       (create-conn "/tmp/test-create-conn" {:likes {:db/cardinality :db.cardinality/many}})

       (create-conn "dtlv://datalevin:secret@example.host/mydb" {} {:auto-entity-time? true})
</code></pre></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L467">view source</a></div></div><div class="public anchor" id="var-datom"><h3>datom</h3><div class="usage"><code>(datom e a v)</code><code>(datom e a v tx)</code><code>(datom e a v tx added)</code></div><div class="doc"><div class="markdown"><p>Low-level fn to create raw datoms in a Datalog db.</p>
<p>Optionally with transaction id (number) and <code>added</code> flag (<code>true</code> for addition, <code>false</code> for retraction).</p>
<p>See also <a href="datalevin.core.html#var-init-db">init-db</a>.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L229">view source</a></div></div><div class="public anchor" id="var-datom-a"><h3>datom-a</h3><div class="usage"><code>(datom-a d)</code></div><div class="doc"><div class="markdown"><p>Return the attribute of a datom</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L245">view source</a></div></div><div class="public anchor" id="var-datom-e"><h3>datom-e</h3><div class="usage"><code>(datom-e d)</code></div><div class="doc"><div class="markdown"><p>Return the entity id of a datom</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L241">view source</a></div></div><div class="public anchor" id="var-datom-v"><h3>datom-v</h3><div class="usage"><code>(datom-v d)</code></div><div class="doc"><div class="markdown"><p>Return the value of a datom</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L249">view source</a></div></div><div class="public anchor" id="var-datom.3F"><h3>datom?</h3><div class="usage"><code>(datom? x)</code></div><div class="doc"><div class="markdown"><p>Returns <code>true</code> if the given value is a datom, <code>false</code> otherwise.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L237">view source</a></div></div><div class="public anchor" id="var-datoms"><h3>datoms</h3><div class="usage"><code>(datoms db index)</code><code>(datoms db index c1)</code><code>(datoms db index c1 c2)</code><code>(datoms db index c1 c2 c3)</code><code>(datoms db index c1 c2 c3 c4)</code></div><div class="doc"><div class="markdown"><p>Index lookup in Datalog db. Returns a sequence of datoms (lazy iterator over actual DB index) which components (e, a, v) match passed arguments.</p>
<p>Datoms are sorted in index sort order. Possible <code>index</code> values are: <code>:eav</code>, <code>:ave</code>, or <code>:vea</code> (only available for :db.type/ref datoms).</p>
<p>Usage:</p>
<pre><code>; find all datoms for entity id == 1 (any attrs and values)
; sort by attribute, then value
(datoms db :eav 1)
; =&gt; (#datalevin/Datom [1 :friends 2]
;     #datalevin/Datom [1 :likes "fries"]
;     #datalevin/Datom [1 :likes "pizza"]
;     #datalevin/Datom [1 :name "Ivan"])

; find all datoms for entity id == 1 and attribute == :likes (any values)
; sorted by value
(datoms db :eav 1 :likes)
; =&gt; (#datalevin/Datom [1 :likes "fries"]
;     #datalevin/Datom [1 :likes "pizza"])

; find all datoms for entity id == 1, attribute == :likes and value == "pizza"
(datoms db :eav 1 :likes "pizza")
; =&gt; (#datalevin/Datom [1 :likes "pizza"])

; find all datoms that have attribute == `:likes` and value == `"pizza"` (any entity id)
(datoms db :ave :likes "pizza")
; =&gt; (#datalevin/Datom [1 :likes "pizza"]
;     #datalevin/Datom [2 :likes "pizza"])

; find all datoms sorted by entity id, then attribute, then value
(datoms db :eav) ; =&gt; (...)
</code></pre>
<p>Useful patterns:</p>
<pre><code>; get all values of :db.cardinality/many attribute
(-&gt;&gt; (datoms db :eav eid attr) (map :v))

; lookup entity ids by attribute value
(-&gt;&gt; (datoms db :ave attr value) (map :e))

; find N entities with lowest attr value (e.g. 10 earliest posts)
(-&gt;&gt; (datoms db :ave attr) (take N))

; find N entities with highest attr value (e.g. 10 latest posts)
(-&gt;&gt; (datoms db :ave attr) (reverse) (take N))
</code></pre>
<p>Gotchas:</p>
<ul>
  <li>Index lookup is usually more efficient than doing a query with a single clause.</li>
  <li>Resulting iterator is calculated in constant time and small constant memory overhead.</li>
</ul></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L297">view source</a></div></div><div class="public anchor" id="var-db"><h3>db</h3><div class="usage"><code>(db conn)</code></div><div class="doc"><div class="markdown"><p>Returns the underlying Datalog database object from a connection. Note that Datalevin does not have “db as a value” feature, the returned object is NOT a database value, but a reference to the database object.</p>
<p>Exists for Datomic API compatibility. </p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L696">view source</a></div></div><div class="public anchor" id="var-db.3F"><h3>db?</h3><div class="usage"><code>(db? x)</code></div><div class="doc"><div class="markdown"><p>Returns <code>true</code> if the given value is a Datalog database. Has the side effect of updating the cache of the db to the most recent. Return <code>false</code> otherwise. </p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L224">view source</a></div></div><div class="public anchor" id="var-dir"><h3>dir</h3><div class="usage"><code>(dir db)</code></div><div class="doc"><div class="markdown"><p>Return the path or URI string of the key-value store</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L953">view source</a></div></div><div class="public anchor" id="var-doc-count"><h3>doc-count</h3><div class="usage"><code>(doc-count engine)</code></div><div class="doc"><div class="markdown"><p>Return the number of documents in the search index</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L1380">view source</a></div></div><div class="public anchor" id="var-doc-indexed.3F"><h3>doc-indexed?</h3><div class="usage"><code>(doc-indexed? engine doc-ref)</code></div><div class="doc"><div class="markdown"><p>Test if a <code>doc-ref</code> is already in the search index</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L1376">view source</a></div></div><div class="public anchor" id="var-doc-refs"><h3>doc-refs</h3><div class="usage"><code>(doc-refs engine)</code></div><div class="doc"><div class="markdown"><p>Return a seq of <code>doc-ref</code> in the search index</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L1384">view source</a></div></div><div class="public anchor" id="var-drop-dbi"><h3>drop-dbi</h3><div class="usage"><code>(drop-dbi db dbi-name)</code></div><div class="doc"><div class="markdown"><p>Clear data in the DBI (i.e. sub-database) of the key-value store, then delete it</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L974">view source</a></div></div><div class="public anchor" id="var-empty-db"><h3>empty-db</h3><div class="usage"><code>(empty-db)</code><code>(empty-db dir)</code><code>(empty-db dir schema)</code><code>(empty-db dir schema opts)</code></div><div class="doc"><div class="markdown"><p>Open a Datalog database at the given location. <code>dir</code> could be a local directory path or a dtlv connection URI string. Creates an empty database there if it does not exist yet. Update the schema if one is given. Return reference to the database.</p>
<p><code>opts</code> map has keys:</p>
<ul>
  <li>
  <p><code>:validate-data?</code>, a boolean, instructing the system to validate data type during transaction. Default is <code>false</code>.</p></li>
  <li>
  <p><code>:auto-entity-time?</code>, a boolean indicating whether to maintain <code>:db/created-at</code> and <code>:db/updated-at</code> values for each entity. Default is <code>false</code>.</p></li>
  <li>
  <p><code>:search-opts</code>, an option map that will be passed to the built-in full-text search engine</p></li>
  <li>
  <p><code>:kv-opts</code>, an option map that will be passed to the underlying kV store</p></li>
</ul>
<p>Usage:</p>
<pre><code>        (empty-db)

        (empty-db "/tmp/test-empty-db")

        (empty-db "/tmp/test-empty-db" {:likes {:db/cardinality :db.cardinality/many}})

        (empty-db "dtlv://datalevin:secret@example.host/mydb" {} {:auto-entity-time? true :search-engine {:analyzer blank-space-analyzer}})
</code></pre></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L199">view source</a></div></div><div class="public anchor" id="var-entid"><h3>entid</h3><div class="usage"><code>(entid db eid)</code></div><div class="doc"><div class="markdown"><p>Given lookup ref <code>[unique-attr value]</code>, returns numberic entity id.</p>
<p><code>db</code> is a Datalog database.</p>
<p>If entity does not exist, returns <code>nil</code>.</p>
<p>For numeric <code>eid</code> returns <code>eid</code> itself (does not check for entity existence in that case).</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L103">view source</a></div></div><div class="public anchor" id="var-entity"><h3>entity</h3><div class="usage"><code>(entity db eid)</code></div><div class="doc"><div class="markdown"><p>Retrieves an entity by its id from a Datalog database. Entities are lazy map-like structures to navigate Datalevin database content.</p>
<p><code>db</code> is a Datalog database.</p>
<p>For <code>eid</code> pass entity id or lookup attr:</p>
<pre><code>(entity db 1)
(entity db [:unique-attr :value])
</code></pre>
<p>If entity does not exist, <code>nil</code> is returned:</p>
<pre><code>(entity db 100500) ; =&gt; nil
</code></pre>
<p>Creating an entity by id is very cheap, almost no-op, as attr access is on-demand:</p>
<pre><code>(entity db 1) ; =&gt; {:db/id 1}
</code></pre>
<p>Entity attributes can be lazily accessed through key lookups:</p>
<pre><code>(:attr (entity db 1)) ; =&gt; :value
(get (entity db 1) :attr) ; =&gt; :value
</code></pre>
<p>Cardinality many attributes are returned sequences:</p>
<pre><code>(:attrs (entity db 1)) ; =&gt; [:v1 :v2 :v3]
</code></pre>
<p>Reference attributes are returned as another entities:</p>
<pre><code>(:ref (entity db 1)) ; =&gt; {:db/id 2}
(:ns/ref (entity db 1)) ; =&gt; {:db/id 2}
</code></pre>
<p>References can be walked backwards by prepending <code>_</code> to name part of an attribute:</p>
<pre><code>(:_ref (entity db 2)) ; =&gt; [{:db/id 1}]
(:ns/_ref (entity db 2)) ; =&gt; [{:db/id 1}]
</code></pre>
<p>Reverse reference lookup returns sequence of entities unless attribute is marked as <code>:db/component</code>:</p>
<pre><code>(:_component-ref (entity db 2)) ; =&gt; {:db/id 1}
</code></pre>
<p>Entity gotchas:</p>
<ul>
  <li>Entities print as map, but are not exactly maps (they have  compatible get interface though).</li>
  <li>Entities retain reference to the database.</li>
  <li>Creating an entity by id is very cheap, almost no-op  (attributes are looked up on demand).</li>
  <li>Comparing entities just compares their ids. Be careful when  comparing entities taken from differenct dbs or from different versions of the  same db.</li>
  <li>Accessed entity attributes are cached on entity itself (except  backward references).</li>
  <li>When printing, only cached attributes (the ones you have accessed before) are printed. See <a href="datalevin.core.html#var-touch">touch</a>.</li>
</ul></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L32">view source</a></div></div><div class="public anchor" id="var-entity-db"><h3>entity-db</h3><div class="usage"><code>(entity-db entity)</code></div><div class="doc"><div class="markdown"><p>Returns a Datalog db that entity was created from.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L116">view source</a></div></div><div class="public anchor" id="var-entries"><h3>entries</h3><div class="usage"><code>(entries db dbi-name)</code></div><div class="doc"><div class="markdown"><p>Get the number of data entries in a DBI (i.e. sub-db) of the key-value store</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L1004">view source</a></div></div><div class="public anchor" id="var-get-conn"><h3>get-conn</h3><div class="usage"><code>(get-conn dir)</code><code>(get-conn dir schema)</code><code>(get-conn dir schema opts)</code></div><div class="doc"><div class="markdown"><p>Obtain an open connection to a Datalog database. <code>dir</code> could be a local directory path or a dtlv connection URI string. Create the database if it does not exist. Reuse the same connection if a connection to the same database already exists. Open the database if it is closed. Return the connection.</p>
<p>See also <a href="datalevin.core.html#var-create-conn">create-conn</a> and <a href="datalevin.core.html#var-with-conn">with-conn</a></p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L759">view source</a></div></div><div class="public anchor" id="var-get-first"><h3>get-first</h3><div class="usage"><code>(get-first db dbi-name k-range)</code><code>(get-first db dbi-name k-range k-type)</code><code>(get-first db dbi-name k-range k-type v-type)</code><code>(get-first db dbi-name k-range k-type v-type ignore-key?)</code></div><div class="doc"><div class="markdown"><p>Return the first kv pair in the specified key range in the key-value store;</p>
<p><code>k-range</code> is a vector <code>[range-type k1 k2]</code>, <code>range-type</code> can be one of  <code>:all</code>, <code>:at-least</code>, <code>:at-most</code>, <code>:closed</code>, <code>:closed-open</code>, <code>:greater-than</code>,  <code>:less-than</code>, <code>:open</code>, <code>:open-closed</code>, plus backward variants that put a  <code>-back</code> suffix to each of the above, e.g. <code>:all-back</code>;</p>
<p><code>k-type</code> and <code>v-type</code> are data types of <code>k</code> and <code>v</code>, respectively.  The allowed data types are described in <a href="datalevin.core.html#var-read-buffer">read-buffer</a>.</p>
<p>Only the value will be returned if <code>ignore-key?</code> is <code>true</code>;  If value is to be ignored, put <code>:ignore</code> as <code>v-type</code></p>
<p>If both key and value are ignored, return true if found an entry, otherwise  return nil.</p>
<p>Examples:</p>
<pre><code>      (get-first lmdb "c" [:all] :long :long)
      ;;==&gt; [0 1]

      ;; ignore value
      (get-first lmdb "c" [:all-back] :long :ignore)
      ;;==&gt; [999 nil]

      ;; ignore key
      (get-first lmdb "a" [:greater-than 9] :long :data true)
      ;;==&gt; {:some :data}

      ;; ignore both, this is like testing if the range is empty
      (get-first lmdb "a" [:greater-than 5] :long :ignore true)
      ;;==&gt; true
</code></pre></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L1075">view source</a></div></div><div class="public anchor" id="var-get-range"><h3>get-range</h3><div class="usage"><code>(get-range db dbi-name k-range)</code><code>(get-range db dbi-name k-range k-type)</code><code>(get-range db dbi-name k-range k-type v-type)</code><code>(get-range db dbi-name k-range k-type v-type ignore-key?)</code></div><div class="doc"><div class="markdown"><p>Return a seq of kv pairs in the specified key range in the key-value store;</p>
<p><code>k-range</code> is a vector <code>[range-type k1 k2]</code>, <code>range-type</code> can be one of  <code>:all</code>, <code>:at-least</code>, <code>:at-most</code>, <code>:closed</code>, <code>:closed-open</code>, <code>:greater-than</code>,  <code>:less-than</code>, <code>:open</code>, <code>:open-closed</code>, plus backward variants that put a  <code>-back</code> suffix to each of the above, e.g. <code>:all-back</code>;</p>
<p><code>k-type</code> and <code>v-type</code> are data types of <code>k</code> and <code>v</code>, respectively.  The allowed data types are described in <a href="datalevin.core.html#var-read-buffer">read-buffer</a>.</p>
<p>Only the value will be returned if <code>ignore-key?</code> is <code>true</code>,  default is <code>false</code>;</p>
<p>If value is to be ignored, put <code>:ignore</code> as <code>v-type</code></p>
<p>Examples:</p>
<pre><code>      (get-range lmdb "c" [:at-least 9] :long :long)
      ;;==&gt; [[10 11] [11 15] [13 14]]

      ;; ignore value
      (get-range lmdb "c" [:all-back] :long :ignore)
      ;;==&gt; [[999 nil] [998 nil]]

      ;; ignore keys, only return values
      (get-range lmdb "a" [:closed 9 11] :long :long true)
      ;;==&gt; [10 11 12]

      ;; out of range
      (get-range lmdb "c" [:greater-than 1500] :long :ignore)
      ;;==&gt; [] 
</code></pre></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L1114">view source</a></div></div><div class="public anchor" id="var-get-some"><h3>get-some</h3><div class="usage"><code>(get-some db dbi-name pred k-range)</code><code>(get-some db dbi-name pred k-range k-type)</code><code>(get-some db dbi-name pred k-range k-type v-type)</code><code>(get-some db dbi-name pred k-range k-type v-type ignore-key?)</code></div><div class="doc"><div class="markdown"><p>Return the first kv pair that has logical true value of <code>(pred x)</code> in  the key-value store, where <code>pred</code> is a function, <code>x</code> is an <code>IKV</code>  fetched from the store, with both key and value fields being a  <code>ByteBuffer</code>.</p>
<p><code>pred</code> can use <a href="datalevin.core.html#var-read-buffer">read-buffer</a> to read the content.</p>
<p>To access store on a server, <a href="null">interpret.inter-fn</a> should be used to define the <code>pred</code>.</p>
<p><code>k-range</code> is a vector <code>[range-type k1 k2]</code>, <code>range-type</code> can be one of  <code>:all</code>, <code>:at-least</code>, <code>:at-most</code>, <code>:closed</code>, <code>:closed-open</code>, <code>:greater-than</code>,  <code>:less-than</code>, <code>:open</code>, <code>:open-closed</code>, plus backward variants that put a  <code>-back</code> suffix to each of the above, e.g. <code>:all-back</code>;</p>
<p><code>k-type</code> and <code>v-type</code> are data types of <code>k</code> and <code>v</code>, respectively.  The allowed data types are described in <a href="datalevin.core.html#var-read-buffer">read-buffer</a>.</p>
<p>Only the value will be returned if <code>ignore-key?</code> is <code>true</code>;  If value is to be ignored, put <code>:ignore</code> as <code>v-type</code></p>
<p>Examples:</p>
<pre><code>      (require '[datalevin.interpret :as i])

      (def pred (i/inter-fn [kv]
                 (let [^long lk (read-buffer (k kv) :long)]
                  (&gt; lk 15)))

      (get-some lmdb "c" pred [:less-than 20] :long :long)
      ;;==&gt; [16 2]

      ;; ignore key
      (get-some lmdb "c" pred [:greater-than 9] :long :data true)
      ;;==&gt; 16 
</code></pre></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L1171">view source</a></div></div><div class="public anchor" id="var-get-value"><h3>get-value</h3><div class="usage"><code>(get-value db dbi-name k)</code><code>(get-value db dbi-name k k-type)</code><code>(get-value db dbi-name k k-type v-type)</code><code>(get-value db dbi-name k k-type v-type ignore-key?)</code></div><div class="doc"><div class="markdown"><p>Get kv pair of the specified key <code>k</code> in the key-value store.</p>
<p><code>k-type</code> and <code>v-type</code> are data types of <code>k</code> and <code>v</code>, respectively. The allowed data types are described in <a href="datalevin.core.html#var-read-buffer">read-buffer</a>.</p>
<p>If <code>ignore-key?</code> is true (default <code>true</code>), only return the value, otherwise return <code>[k v]</code>, where <code>v</code> is the value</p>
<p>Examples:</p>
<pre><code>  (get-value lmdb "a" 1)
  ;;==&gt; 2

  ;; specify data types
  (get-value lmdb "a" :annunaki/enki :attr :data)
  ;;==&gt; true

  ;; return key value pair
  (get-value lmdb "a" 1 :data :data false)
  ;;==&gt; [1 2]

  ;; key doesn't exist
  (get-value lmdb "a" 2)
  ;;==&gt; nil 
</code></pre></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L1045">view source</a></div></div><div class="public anchor" id="var-hexify-string"><h3>hexify-string</h3><div class="usage"><code>(hexify-string s)</code></div><div class="doc"><div class="markdown"><p>Turn a string into a hexified string</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L1481">view source</a></div></div><div class="public anchor" id="var-index-range"><h3>index-range</h3><div class="usage"><code>(index-range db attr start end)</code></div><div class="doc"><div class="markdown"><p>Returns part of <code>:avet</code> index between <code>[_ attr start]</code> and <code>[_ attr end]</code> in AVET sort order.</p>
<p>Same properties as <a href="datalevin.core.html#var-datoms">datoms</a>.</p>
<p>Usage:</p>
<pre><code>(index-range db :likes "a" "zzzzzzzzz")
; =&gt; (#datalevin/Datom [2 :likes "candy"]
;     #datalevin/Datom [1 :likes "fries"]
;     #datalevin/Datom [2 :likes "pie"]
;     #datalevin/Datom [1 :likes "pizza"]
;     #datalevin/Datom [2 :likes "pizza"])

(index-range db :likes "egg" "pineapple")
; =&gt; (#datalevin/Datom [1 :likes "fries"]
;     #datalevin/Datom [2 :likes "pie"])
</code></pre>
<p>Useful patterns:</p>
<pre><code>; find all entities with age in a specific range (inclusive)
(-&gt;&gt; (index-range db :age 18 60) (map :e))
</code></pre></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L403">view source</a></div></div><div class="public anchor" id="var-init-db"><h3>init-db</h3><div class="usage"><code>(init-db datoms)</code><code>(init-db datoms dir)</code><code>(init-db datoms dir schema)</code><code>(init-db datoms dir schema opts)</code></div><div class="doc"><div class="markdown"><p>Low-level function for creating a Datalog database quickly from a trusted sequence of datoms, useful for bulk data loading. <code>dir</code> could be a local directory path or a dtlv connection URI string. Does no validation on inputs, so <code>datoms</code> must be well-formed and match schema.</p>
<p><code>opts</code> map has keys:</p>
<ul>
  <li>
  <p><code>:validate-data?</code>, a boolean, instructing the system to validate data type during transaction. Default is <code>false</code>.</p></li>
  <li>
  <p><code>:auto-entity-time?</code>, a boolean indicating whether to maintain <code>:db/created-at</code> and <code>:db/updated-at</code> values for each entity. Default is <code>false</code>.</p></li>
  <li>
  <p><code>:search-opts</code>, an option map that will be passed to the built-in full-text search engine</p></li>
  <li>
    <p><code>:kv-opts</code>, an option map that will be passed to the underlying kV store</p>
    <pre><code>    See also [[datom]], [[new-search-engine]].
</code></pre>
  </li>
</ul></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L253">view source</a></div></div><div class="public anchor" id="var-k"><h3>k</h3><div class="usage"><code>(k kv)</code></div><div class="doc"><div class="markdown"><p>Key of a key value pair</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L904">view source</a></div></div><div class="public anchor" id="var-list-dbis"><h3>list-dbis</h3><div class="usage"><code>(list-dbis db)</code></div><div class="doc"><div class="markdown"><p>List the names of the sub-databases in the key-value store</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L978">view source</a></div></div><div class="public anchor" id="var-listen.21"><h3>listen!</h3><div class="usage"><code>(listen! conn callback)</code><code>(listen! conn key callback)</code></div><div class="doc"><div class="markdown"><p>Listen for changes on the given connection to a Datalog db. Whenever a transaction is applied to the database via <a href="datalevin.core.html#var-transact.21">transact!</a>, the callback is called with the transaction report. <code>key</code> is any opaque unique value.</p>
<p>Idempotent. Calling <a href="datalevin.core.html#var-listen.21">listen!</a> with the same key twice will override old callback with the new value.</p>
<p>Returns the key under which this listener is registered. See also <a href="datalevin.core.html#var-unlisten.21">unlisten!</a>.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L648">view source</a></div></div><div class="public anchor" id="var-new-search-engine"><h3>new-search-engine</h3><div class="usage"><code>(new-search-engine lmdb)</code><code>(new-search-engine lmdb opts)</code></div><div class="doc"><div class="markdown"><p>Create a search engine. The search index is stored in the passed-in key-value database opened by <a href="datalevin.core.html#var-open-kv">open-kv</a>.</p>
<p><code>opts</code> is an option map that may contain these keys:</p>
<ul>
  <li>
  <p><code>:domain</code> is an identifier string, indicates the domain of this search engine. This way, multiple independent search engines can reside in the same key-value database, each with its own domain identifier.</p></li>
  <li>
  <p><code>:analyzer</code> is a function that takes a text string and return a seq of  [term, position, offset], where term is a word, position is the sequence  number of the term in the document, and offset is the character offset of  the term in the document. E.g. for a blank space analyzer and the document  “The quick brown fox jumps over the lazy dog”, [“quick” 1 4] would be  the second entry of the resulting seq.</p></li>
  <li>
  <p><code>:query-analyzer</code> is a similar function that overrides the analyzer at  query time (and not indexing time). Mostly useful for autocomplete search in  conjunction with the <code>datalevin.search-utils/prefix-token-filter</code>.</p></li>
</ul>
<p>See <a href="datalevin.search-utils.html">datalevin.search-utils</a> for some functions to customize search.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L1326">view source</a></div></div><div class="public anchor" id="var-open-dbi"><h3>open-dbi</h3><div class="usage"><code>(open-dbi db dbi-name)</code><code>(open-dbi db dbi-name opts)</code></div><div class="doc"><div class="markdown"><p>Open a named DBI (i.e. sub-db) in the key-value store. <code>opts</code> is an option map that may have the following keys:</p>
<ul>
  <li>
  <p><code>:validate-data?</code>, a boolean, instructing the system to validate data type during transaction. Default is <code>false</code>.</p></li>
  <li>
  <p><code>:key-size</code> is the max size of the key in bytes, cannot be greater than 511, default is 511.</p></li>
  <li>
  <p><code>:val-size</code> is the default size of the value in bytes, Datalevin will automatically increase the size if a larger value is transacted.</p></li>
  <li>
  <p><code>:flags</code> is a vector of LMDB Dbi flag keywords, may include <code>:reversekey</code>, <code>:dupsort</code>, <code>integerkey</code>, <code>dupfixed</code>, <code>integerdup</code>, <code>reversedup</code>, or <code>create</code>, default is <code>[:create]</code>, see <a href="http://www.lmdb.tech/doc/group__mdb__dbi__open.html">LMDB documentation</a>.</p></li>
</ul></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L957">view source</a></div></div><div class="public anchor" id="var-open-kv"><h3>open-kv</h3><div class="usage"><code>(open-kv dir)</code><code>(open-kv dir opts)</code></div><div class="doc"><div class="markdown"><p>Open a LMDB key-value database, return the connection.</p>
<p><code>dir</code> is a directory path or a dtlv connection URI string. <code>opts</code> is an option map that may have the following keys: * <code>:mapsize</code> is the initial size of the database. This will be expanded as needed * <code>:flags</code> is a vector of keywords corresponding to LMDB environment flags, e.g.  <code>:rdonly-env</code> for MDB_RDONLY_ENV, <code>:nosubdir</code> for MDB_NOSUBDIR, and so on. See <a href="http://www.lmdb.tech/doc/group__mdb__env.html">LMDB Documentation</a></p>
<p>Please note:</p>
<blockquote>
  <p>LMDB uses POSIX locks on files, and these locks have issues if one process opens a file multiple times. Because of this, do not mdb_env_open() a file multiple times from a single process. Instead, share the LMDB environment that has opened the file across all threads. Otherwise, if a single process opens the same environment multiple times, closing it once will remove all the locks held on it, and the other instances will be vulnerable to corruption from other processes.’</p>
</blockquote>
<p>Therefore, a LMDB connection should be managed as a stateful resource. Multiple connections to the same DB in the same process are not recommended. The recommendation is to use a mutable state management library, for example, in Clojure, use <a href="https://github.com/stuartsierra/component">component</a>, <a href="https://github.com/tolitius/mount">mount</a>, <a href="https://github.com/weavejester/integrant">integrant</a>, or something similar to hold on to and manage the connection. </p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L912">view source</a></div></div><div class="public anchor" id="var-opts"><h3>opts</h3><div class="usage"><code>(opts conn)</code></div><div class="doc"><div class="markdown"><p>Return the option map of the Datalog DB</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L704">view source</a></div></div><div class="public anchor" id="var-pull"><h3>pull</h3><div class="usage"><code>(pull db selector eid)</code></div><div class="doc"><div class="markdown"><p>Fetches data from a Datalog database using recursive declarative description. See <a href="https://docs.datomic.com/on-prem/pull.html">docs.datomic.com/on-prem/pull.html</a>.</p>
<p>Unlike <a href="datalevin.core.html#var-entity">entity</a>, returns plain Clojure map (not lazy).</p>
<p>Usage:</p>
<pre><code>          (pull db [:db/id, :name, :likes, {:friends [:db/id :name]}] 1)
          ; =&gt; {:db/id   1,
          ;     :name    "Ivan"
          ;     :likes   [:pizza]
          ;     :friends [{:db/id 2, :name "Oleg"}]}
</code></pre></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L136">view source</a></div></div><div class="public anchor" id="var-pull-many"><h3>pull-many</h3><div class="usage"><code>(pull-many db selector eids)</code></div><div class="doc"><div class="markdown"><p>Same as <a href="datalevin.core.html#var-pull">pull</a>, but accepts sequence of ids and returns sequence of maps.</p>
<p>Usage:</p>
<pre><code>       (pull-many db [:db/id :name] [1 2])
       ; =&gt; [{:db/id 1, :name "Ivan"}
       ;     {:db/id 2, :name "Oleg"}]
</code></pre></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L154">view source</a></div></div><div class="public anchor" id="var-put-buffer"><h3>put-buffer</h3><div class="usage"><code>(put-buffer bf x)</code><code>(put-buffer bf x x-type)</code></div><div class="doc"><div class="markdown"><p>Put the given type of data <code>x</code> in buffer <code>bf</code>. <code>x-type</code> can be  one of the following data types:</p>
<ul>
  <li><code>:data</code> (default), arbitrary EDN data, avoid this as keys for range queries</li>
  <li><code>:string</code>, UTF-8 string</li>
  <li><code>:int</code>, 32 bits integer</li>
  <li><code>:long</code>, 64 bits integer</li>
  <li><code>:float</code>, 32 bits IEEE754 floating point number</li>
  <li><code>:double</code>, 64 bits IEEE754 floating point number</li>
  <li><code>:byte</code>, single byte</li>
  <li><code>:bytes</code>, byte array</li>
  <li><code>:keyword</code>, EDN keyword</li>
  <li><code>:symbol</code>, EDN symbol</li>
  <li><code>:boolean</code>, <code>true</code> or <code>false</code></li>
  <li><code>:instant</code>, timestamp, same as <code>java.util.Date</code></li>
  <li><code>:uuid</code>, UUID, same as <code>java.util.UUID</code></li>
</ul>
<p>If the value is to be put in a LMDB key buffer, it must be less than 511 bytes.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L1440">view source</a></div></div><div class="public anchor" id="var-q"><h3>q</h3><div class="usage"><code>(q query &amp; inputs)</code></div><div class="doc"><div class="markdown"><p>Executes a Datalog query. See <a href="https://docs.datomic.com/on-prem/query.html">docs.datomic.com/on-prem/query.html</a>.</p>
<p>Usage:</p>
<pre><code>(q '[:find ?value
     :where [_ :likes ?value]]
   db)
; =&gt; #{["fries"] ["candy"] ["pie"] ["pizza"]}
</code></pre></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L181">view source</a></div></div><div class="public anchor" id="var-range-count"><h3>range-count</h3><div class="usage"><code>(range-count db dbi-name k-range)</code><code>(range-count db dbi-name k-range k-type)</code></div><div class="doc"><div class="markdown"><p>Return the number of kv pairs in the specified key range in the key-value store, does not process the kv pairs.</p>
<p><code>k-range</code> is a vector <code>[range-type k1 k2]</code>, <code>range-type</code> can be one of  <code>:all</code>, <code>:at-least</code>, <code>:at-most</code>, <code>:closed</code>, <code>:closed-open</code>, <code>:greater-than</code>,  <code>:less-than</code>, <code>:open</code>, <code>:open-closed</code>, plus backward variants that put a  <code>-back</code> suffix to each of the above, e.g. <code>:all-back</code>;</p>
<p><code>k-type</code> and <code>v-type</code> are data types of <code>k</code> and <code>v</code>, respectively.  The allowed data types are described in <a href="datalevin.core.html#var-read-buffer">read-buffer</a>.</p>
<p>Examples:</p>
<pre><code>      (range-count lmdb "c" [:at-least 9] :long)
      ;;==&gt; 10 
</code></pre></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L1152">view source</a></div></div><div class="public anchor" id="var-range-filter"><h3>range-filter</h3><div class="usage"><code>(range-filter db dbi-name pred k-range)</code><code>(range-filter db dbi-name pred k-range k-type)</code><code>(range-filter db dbi-name pred k-range k-type v-type)</code><code>(range-filter db dbi-name pred k-range k-type v-type ignore-key?)</code></div><div class="doc"><div class="markdown"><p>Return a seq of kv pair in the specified key range in the key-value store, for only those  return true value for <code>(pred x)</code>, where <code>pred</code> is a function, and <code>x</code>  is an <code>IKV</code>, with both key and value fields being a <code>ByteBuffer</code>.</p>
<p><code>pred</code> can use <a href="datalevin.core.html#var-read-buffer">read-buffer</a> to read the buffer content.</p>
<p>To access store on a server, <a href="null">interpret.inter-fn</a> should be used to define the <code>pred</code>.</p>
<p><code>k-range</code> is a vector <code>[range-type k1 k2]</code>, <code>range-type</code> can be one of  <code>:all</code>, <code>:at-least</code>, <code>:at-most</code>, <code>:closed</code>, <code>:closed-open</code>, <code>:greater-than</code>,  <code>:less-than</code>, <code>:open</code>, <code>:open-closed</code>, plus backward variants that put a  <code>-back</code> suffix to each of the above, e.g. <code>:all-back</code>;</p>
<p><code>k-type</code> and <code>v-type</code> are data types of <code>k</code> and <code>v</code>, respectively.  The allowed data types are described in <a href="datalevin.core.html#var-read-buffer">read-buffer</a>.</p>
<p>Only the value will be returned if <code>ignore-key?</code> is <code>true</code>;  If value is to be ignored, put <code>:ignore</code> as <code>v-type</code></p>
<p>Examples:</p>
<pre><code>      (require '[datalevin.interpret :as i])

      (def pred (i/inter-fn [kv]
                 (let [^long lk (read-buffer (k kv) :long)]
                  (&gt; lk 15)))

      (range-filter lmdb "a" pred [:less-than 20] :long :long)
      ;;==&gt; [[16 2] [17 3]]

      ;; ignore key
      (range-filter lmdb "a" pred [:greater-than 9] :long :data true)
      ;;==&gt; [16 17] 
</code></pre></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L1212">view source</a></div></div><div class="public anchor" id="var-range-filter-count"><h3>range-filter-count</h3><div class="usage"><code>(range-filter-count db dbi-name pred k-range)</code><code>(range-filter-count db dbi-name pred k-range k-type)</code></div><div class="doc"><div class="markdown"><p>Return the number of kv pairs in the specified key range in the key-value store, for only those return true value for <code>(pred x)</code>, where <code>pred</code> is a function, and <code>x</code>is an <code>IKV</code>, with both key and value fields being a <code>ByteBuffer</code>. Does not process the kv pairs.</p>
<pre><code> `pred` can use [[read-buffer]] to read the buffer content.

  To access store on a server, [[interpret.inter-fn]] should be used to define
</code></pre>
<p>the <code>pred</code>.</p>
<pre><code>`k-type` indicates data type of `k` and the allowed data types are described
in [[read-buffer]].

 `k-range` is a vector `[range-type k1 k2]`, `range-type` can be one of
 `:all`, `:at-least`, `:at-most`, `:closed`, `:closed-open`, `:greater-than`,
 `:less-than`, `:open`, `:open-closed`, plus backward variants that put a
 `-back` suffix to each of the above, e.g. `:all-back`;

 Examples:

          (require '[datalevin.interpret :as i])

          (def pred (i/inter-fn [kv]
                     (let [^long lk (read-buffer (k kv) :long)]
                      (&gt; lk 15))))

          (range-filter-count lmdb "a" pred [:less-than 20] :long)
          ;;==&gt; 3
</code></pre></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L1251">view source</a></div></div><div class="public anchor" id="var-read-buffer"><h3>read-buffer</h3><div class="usage"><code>(read-buffer bf)</code><code>(read-buffer bf v-type)</code></div><div class="doc"><div class="markdown"><p>Get the given type of data from buffer <code>bf</code>, <code>v-type</code> can be one of the following data types:</p>
<ul>
  <li><code>:data</code> (default), arbitrary EDN data</li>
  <li><code>:string</code>, UTF-8 string</li>
  <li><code>:int</code>, 32 bits integer</li>
  <li><code>:long</code>, 64 bits integer</li>
  <li><code>:float</code>, 32 bits IEEE754 floating point number</li>
  <li><code>:double</code>, 64 bits IEEE754 floating point number</li>
  <li><code>:byte</code>, single byte</li>
  <li><code>:bytes</code>, an byte array</li>
  <li><code>:keyword</code>, EDN keyword</li>
  <li><code>:symbol</code>, EDN symbol</li>
  <li><code>:boolean</code>, <code>true</code> or <code>false</code></li>
  <li><code>:instant</code>, timestamp, same as <code>java.util.Date</code></li>
  <li><code>:uuid</code>, UUID, same as <code>java.util.UUID</code></li>
</ul></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L1462">view source</a></div></div><div class="public anchor" id="var-remove-doc"><h3>remove-doc</h3><div class="usage"><code>(remove-doc engine doc-ref)</code></div><div class="doc"><div class="markdown"><p>Remove a document referred to by <code>doc-ref</code> from the search engine index. A slow operation.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L1366">view source</a></div></div><div class="public anchor" id="var-reset-conn.21"><h3>reset-conn!</h3><div class="usage"><code>(reset-conn! conn db)</code><code>(reset-conn! conn db tx-meta)</code></div><div class="doc"><div class="markdown"><p>Forces underlying <code>conn</code> value to become a Datalog <code>db</code>. Will generate a tx-report that will remove everything from old value and insert everything from the new one.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L625">view source</a></div></div><div class="public anchor" id="var-resolve-tempid"><h3>resolve-tempid</h3><div class="usage"><code>(resolve-tempid _db tempids tempid)</code></div><div class="doc"><div class="markdown"><p>Does a lookup in tempids map, returning an entity id that tempid was resolved to.</p>
<p>Exists for Datomic API compatibility. Prefer using map lookup directly if possible.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L688">view source</a></div></div><div class="public anchor" id="var-retract"><h3>retract</h3><div class="usage"><code>(retract ent attr)</code><code>(retract ent attr value)</code></div><div class="doc"><div class="markdown"><p>Remove an attribute from an entity of a Datalog database</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L99">view source</a></div></div><div class="public anchor" id="var-rseek-datoms"><h3>rseek-datoms</h3><div class="usage"><code>(rseek-datoms db index)</code><code>(rseek-datoms db index c1)</code><code>(rseek-datoms db index c1 c2)</code><code>(rseek-datoms db index c1 c2 c3)</code><code>(rseek-datoms db index c1 c2 c3 c4)</code></div><div class="doc"><div class="markdown"><p>Same as <a href="datalevin.core.html#var-seek-datoms">seek-datoms</a>, but goes backwards until the beginning of the index.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L394">view source</a></div></div><div class="public anchor" id="var-schema"><h3>schema</h3><div class="usage"><code>(schema conn)</code></div><div class="doc"><div class="markdown"><p>Return the schema of Datalog DB</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L710">view source</a></div></div><div class="public anchor" id="var-search"><h3>search</h3><div class="usage"><code>(search engine query)</code><code>(search engine query opts)</code></div><div class="doc"><div class="markdown"><p>Issue a <code>query</code> to the search engine. <code>query</code> is a string of words.</p>
<pre><code> `opts` map may have these keys:

  * `:display` can be one of `:refs` (default), `:offsets`.
    - `:refs` return a lazy sequence of `doc-ref` ordered by relevance.
    - `:offsets` return a lazy sequence of
      `[doc-ref [term1 [offset ...]] [term2 [...]] ...]`,
      ordered by relevance. `term` and `offset` can be used to
      highlight the matched terms and their locations in the documents.
  * `:top` is an integer (default 10), the number of results desired.
  * `:doc-filter` is a boolean function that takes a `doc-ref` and
     determines whether or not to include the corresponding document in the
     results (default is `(constantly true)`)
</code></pre></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L1388">view source</a></div></div><div class="public anchor" id="var-search-index-writer"><h3>search-index-writer</h3><div class="usage"><code>(search-index-writer lmdb)</code><code>(search-index-writer lmdb opts)</code></div><div class="doc"><div class="markdown"><p>Create a writer for writing documents to the search index in bulk. The search index is stored in the passed-in key value database opened by <a href="datalevin.core.html#var-open-kv">open-kv</a>. See also <a href="datalevin.core.html#var-write">write</a> and <a href="datalevin.core.html#var-commit">commit</a>.</p>
<p><code>opts</code> is an option map that may contain these keys:</p>
<ul>
  <li>
  <p><code>:domain</code> is an identifier string, indicates the domain of this search engine. This way, multiple independent search engines can reside in the same key-value database, each with its own domain identifier.</p></li>
  <li>
  <p><code>:analyzer</code> is a function that takes a text string and return a seq of  [term, position, offset], where term is a word, position is the sequence  number of the term, and offset is the character offset of this term.</p></li>
</ul></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L1406">view source</a></div></div><div class="public anchor" id="var-seek-datoms"><h3>seek-datoms</h3><div class="usage"><code>(seek-datoms db index)</code><code>(seek-datoms db index c1)</code><code>(seek-datoms db index c1 c2)</code><code>(seek-datoms db index c1 c2 c3)</code><code>(seek-datoms db index c1 c2 c3 c4)</code></div><div class="doc"><div class="markdown"><p>Similar to <a href="datalevin.core.html#var-datoms">datoms</a>, but will return datoms starting from specified components and including rest of the database until the end of the index.</p>
<p>If no datom matches passed arguments exactly, iterator will start from first datom that could be considered “greater” in index order.</p>
<p>Usage:</p>
<pre><code>(seek-datoms db :eavt 1)
; =&gt; (#datalevin/Datom [1 :friends 2]
;     #datalevin/Datom [1 :likes "fries"]
;     #datalevin/Datom [1 :likes "pizza"]
;     #datalevin/Datom [1 :name "Ivan"]
;     #datalevin/Datom [2 :likes "candy"]
;     #datalevin/Datom [2 :likes "pie"]
;     #datalevin/Datom [2 :likes "pizza"])

(seek-datoms db :eavt 1 :name)
; =&gt; (#datalevin/Datom [1 :name "Ivan"]
;     #datalevin/Datom [2 :likes "candy"]
;     #datalevin/Datom [2 :likes "pie"]
;     #datalevin/Datom [2 :likes "pizza"])

(seek-datoms db :eavt 2)
; =&gt; (#datalevin/Datom [2 :likes "candy"]
;     #datalevin/Datom [2 :likes "pie"]
;     #datalevin/Datom [2 :likes "pizza"])

; no datom [2 :likes "fish"], so starts with one immediately following such in index
(seek-datoms db :eavt 2 :likes "fish")
; =&gt; (#datalevin/Datom [2 :likes "pie"]
;     #datalevin/Datom [2 :likes "pizza"])
</code></pre></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L356">view source</a></div></div><div class="public anchor" id="var-stat"><h3>stat</h3><div class="usage"><code>(stat db)</code><code>(stat db dbi-name)</code></div><div class="doc"><div class="markdown"><p>Return the statitics of the unnamed top level database or a named DBI (i.e. sub-database) of the key-value store as a map: * <code>:psize</code> is the size of database page * <code>:depth</code> is the depth of the B-tree * <code>:branch-pages</code> is the number of internal pages * <code>:leaf-pages</code> is the number of leaf pages * <code>:overflow-pages</code> is the number of overflow-pages * <code>:entries</code> is the number of data entries</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L994">view source</a></div></div><div class="public anchor" id="var-tempid"><h3>tempid</h3><div class="usage"><code>(tempid part)</code><code>(tempid part x)</code></div><div class="doc"><div class="markdown"><p>Allocates and returns an unique temporary id (a negative integer). Ignores <code>part</code>. Returns <code>x</code> if it is specified.</p>
<p>Exists for Datomic API compatibility. Prefer using negative integers directly if possible.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L674">view source</a></div></div><div class="public anchor" id="var-touch"><h3>touch</h3><div class="usage"><code>(touch e)</code></div><div class="doc"><div class="markdown"><p>Forces all entity attributes to be eagerly fetched and cached. Only usable for debug output.</p>
<p>Usage:</p>
<pre><code>         (entity db 1) ; =&gt; {:db/id 1}
         (touch (entity db 1)) ; =&gt; {:db/id 1, :dislikes [:pie], :likes [:pizza]}
</code></pre></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L122">view source</a></div></div><div class="public anchor" id="var-transact"><h3>transact</h3><div class="usage"><code>(transact conn tx-data)</code><code>(transact conn tx-data tx-meta)</code></div><div class="doc"><div class="markdown"><p>Same as <a href="datalevin.core.html#var-transact.21">transact!</a>, but returns an immediately realized future.</p>
<p>Exists for Datomic API compatibility. Prefer using <a href="datalevin.core.html#var-transact.21">transact!</a> if possible.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L801">view source</a></div></div><div class="public anchor" id="var-transact.21"><h3>transact!</h3><div class="usage"><code>(transact! conn tx-data)</code><code>(transact! conn tx-data tx-meta)</code></div><div class="doc"><div class="markdown"><p>Applies transaction to the underlying Datalog database of a connection.</p>
<p>Returns transaction report, a map:</p>
<pre><code> { :db-before ...
   :db-after  ...
   :tx-data   [...]     ; plain datoms that were added/retracted from db-before
   :tempids   {...}     ; map of tempid from tx-data =&gt; assigned entid in db-after
   :tx-meta   tx-meta } ; the exact value you passed as `tx-meta`
</code></pre>
<p>Note! <code>conn</code> will be updated in-place and is not returned from <a href="datalevin.core.html#var-transact.21">transact!</a>.</p>
<p>Usage:</p>
<pre><code>; add a single datom to an existing entity (1)
(transact! conn [[:db/add 1 :name "Ivan"]])

; retract a single datom
(transact! conn [[:db/retract 1 :name "Ivan"]])

; retract single entity attribute
(transact! conn [[:db.fn/retractAttribute 1 :name]])

; ... or equivalently (since Datomic changed its API to support this):
(transact! conn [[:db/retract 1 :name]])

; retract all entity attributes (effectively deletes entity)
(transact! conn [[:db.fn/retractEntity 1]])

; create a new entity (`-1`, as any other negative value, is a tempid
; that will be replaced with Datalevin to a next unused eid)
(transact! conn [[:db/add -1 :name "Ivan"]])

; check assigned id (here `*1` is a result returned from previous `transact!` call)
(def report *1)
(:tempids report) ; =&gt; {-1 296}

; check actual datoms inserted
(:tx-data report) ; =&gt; [#datalevin/Datom [296 :name "Ivan"]]

; tempid can also be a string
(transact! conn [[:db/add "ivan" :name "Ivan"]])
(:tempids *1) ; =&gt; {"ivan" 297}

; reference another entity (must exist)
(transact! conn [[:db/add -1 :friend 296]])

; create an entity and set multiple attributes (in a single transaction
; equal tempids will be replaced with the same unused yet entid)
(transact! conn [[:db/add -1 :name "Ivan"]
                 [:db/add -1 :likes "fries"]
                 [:db/add -1 :likes "pizza"]
                 [:db/add -1 :friend 296]])

; create an entity and set multiple attributes (alternative map form)
(transact! conn [{:db/id  -1
                  :name   "Ivan"
                  :likes  ["fries" "pizza"]
                  :friend 296}])

; update an entity (alternative map form). Can’t retract attributes in
; map form. For cardinality many attrs, value (fish in this example)
; will be added to the list of existing values
(transact! conn [{:db/id  296
                  :name   "Oleg"
                  :likes  ["fish"]}])

; ref attributes can be specified as nested map, that will create netsed entity as well
(transact! conn [{:db/id  -1
                  :name   "Oleg"
                  :friend {:db/id -2
                           :name "Sergey"}])

; reverse attribute name can be used if you want created entity to become
; a value in another entity reference
(transact! conn [{:db/id  -1
                  :name   "Oleg"
                  :_friend 296}])
; equivalent to
(transact! conn [{:db/id  -1, :name   "Oleg"}
                 {:db/id 296, :friend -1}])
; equivalent to
(transact! conn [[:db/add  -1 :name   "Oleg"]
                 {:db/add 296 :friend -1]])
</code></pre></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L531">view source</a></div></div><div class="public anchor" id="var-transact-async"><h3>transact-async</h3><div class="usage"><code>(transact-async conn tx-data)</code><code>(transact-async conn tx-data tx-meta)</code></div><div class="doc"><div class="markdown"><p>Calls <a href="datalevin.core.html#var-transact.21">transact!</a> on a future thread pool, returning immediately.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L842">view source</a></div></div><div class="public anchor" id="var-transact-kv"><h3>transact-kv</h3><div class="usage"><code>(transact-kv db txs)</code></div><div class="doc"><div class="markdown"><p>Update DB, insert or delete key value pairs in the key-value store.</p>
<p><code>txs</code> is a seq of <code>[op dbi-name k v k-type v-type append?]</code> when <code>op</code> is <code>:put</code>, for insertion of a key value pair <code>k</code> and <code>v</code>; or <code>[op dbi-name k k-type]</code> when <code>op</code> is <code>:del</code>, for deletion of key <code>k</code>;</p>
<p><code>dbi-name</code> is the name of the DBI (i.e sub-db) to be transacted, a string.</p>
<p><code>k-type</code>, <code>v-type</code> and <code>append?</code> are optional.</p>
<p><code>k-type</code> indicates the data type of <code>k</code>, and <code>v-type</code> indicates the data type of <code>v</code>. The allowed data types are described in <a href="datalevin.core.html#var-put-buffer">put-buffer</a></p>
<p>Set <code>append?</code> to true when the data is sorted to gain better write performance.</p>
<p>Example:</p>
<pre><code>    (transact-kv
      lmdb
      [ [:put "a" 1 2]
      [:put "a" 'a 1]
      [:put "a" 5 {}]
      [:put "a" :annunaki/enki true :attr :data]
      [:put "a" :datalevin ["hello" "world"]]
      [:put "a" 42 (d/datom 1 :a/b {:id 4}) :long :datom]
      [:put "a" (byte 0x01) #{1 2} :byte :data]
      [:put "a" (byte-array [0x41 0x42]) :bk :bytes :data]
      [:put "a" [-1 -235254457N] 5]
      [:put "a" :a 4]
      [:put "a" :bv (byte-array [0x41 0x42 0x43]) :data :bytes]
      [:put "a" :long 1 :data :long]
      [:put "a" 2 3 :long :long]
      [:del "a" 1]
      [:del "a" :non-exist] ])
</code></pre></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L1008">view source</a></div></div><div class="public anchor" id="var-unhexify-string"><h3>unhexify-string</h3><div class="usage"><code>(unhexify-string s)</code></div><div class="doc"><div class="markdown"><p>Turn a hexified string back into a normal string</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L1485">view source</a></div></div><div class="public anchor" id="var-unlisten.21"><h3>unlisten!</h3><div class="usage"><code>(unlisten! conn key)</code></div><div class="doc"><div class="markdown"><p>Removes registered listener from connection. See also <a href="datalevin.core.html#var-listen.21">listen!</a>.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L664">view source</a></div></div><div class="public anchor" id="var-update-schema"><h3>update-schema</h3><div class="usage"><code>(update-schema conn schema-update)</code><code>(update-schema conn schema-update del-attrs)</code><code>(update-schema conn schema-update del-attrs rename-map)</code></div><div class="doc"><div class="markdown"><p>Update the schema of an open connection to a Datalog db.</p>
<ul>
  <li>
  <p><code>schema-update</code> is a map from attribute keywords to maps of corresponding properties.</p></li>
  <li>
  <p><code>del-attrs</code> is a set of attributes to be removed from the schema, if there is no datoms associated with them, otherwise an exception will be thrown.</p></li>
  <li>
  <p><code>rename-map</code> is a map of old attributes to new attributes, for renaming attributes</p></li>
</ul>
<p>Return the updated schema.</p>
<p>Example:</p>
<pre><code>  (update-schema conn {:new/attr {:db/valueType :db.type/string}})
  (update-schema conn {:new/attr {:db/valueType :db.type/string}}
                      #{:old/attr1 :old/attr2})
  (update-schema conn nil nil {:old/attr :new/attr}) 
</code></pre></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L716">view source</a></div></div><div class="public anchor" id="var-v"><h3>v</h3><div class="usage"><code>(v kv)</code></div><div class="doc"><div class="markdown"><p>Value of a key value pair</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L908">view source</a></div></div><div class="public anchor" id="var-visit"><h3>visit</h3><div class="usage"><code>(visit db dbi-name pred k-range)</code><code>(visit db dbi-name pred k-range k-type)</code></div><div class="doc"><div class="markdown"><p>Call <code>visitor</code> function on each kv pairs in the specified key range, presumably for side effects. Return nil. Each kv pair is an <code>IKV</code>, with both key and value fields being a <code>ByteBuffer</code>. <code>visitor</code> function can use <a href="datalevin.core.html#var-read-buffer">read-buffer</a> to read the buffer content.</p>
<p>If <code>visitor</code> function returns a special value <code>:datalevin/terminate-visit</code>, the visit will stop immediately.</p>
<p>For client/server usage, <a href="null">interpret.inter-fn</a> should be used to define the <code>visitor</code> function. For babashka pod usage, <code>defpodfn</code> should be used.</p>
<p><code>k-type</code> indicates data type of <code>k</code> and the allowed data types are described in <a href="datalevin.core.html#var-read-buffer">read-buffer</a>.</p>
<p><code>k-range</code> is a vector <code>[range-type k1 k2]</code>, <code>range-type</code> can be one of  <code>:all</code>, <code>:at-least</code>, <code>:at-most</code>, <code>:closed</code>, <code>:closed-open</code>, <code>:greater-than</code>,  <code>:less-than</code>, <code>:open</code>, <code>:open-closed</code>, plus backward variants that put a  <code>-back</code> suffix to each of the above, e.g. <code>:all-back</code>;</p>
<p>Examples:</p>
<pre><code>      (require '[datalevin.interpret :as i])
      (import '[java.util Hashmap])

      (def hashmap (HashMap.))
      (def visitor (i/inter-fn [kv]
                     (let [^long k (b/read-buffer (l/k kv) :long)
                           ^long v (b/read-buffer (l/v kv) :long)]
                          (.put hashmap k v))))
      (visit lmdb "a" visitor [:closed 11 19] :long)
</code></pre></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L1283">view source</a></div></div><div class="public anchor" id="var-with-conn"><h3>with-conn</h3><h4 class="type">macro</h4><div class="usage"><code>(with-conn spec &amp; body)</code></div><div class="doc"><div class="markdown"><p>Evaluate body in the context of an connection to the Datalog database.</p>
<p>If the database does not exist, this will create it. If it is closed, this will open it. However, the connection will be closed in the end of this call. If a database needs to be kept open, use <code>create-conn</code> and hold onto the returned connection. See also <a href="datalevin.core.html#var-create-conn">create-conn</a> and <a href="datalevin.core.html#var-get-conn">get-conn</a></p>
<p><code>spec</code> is a vector of an identifier of the database connection, a path or dtlv URI string, and optionally a schema map.</p>
<p>Example:</p>
<pre><code>    (with-conn [conn "my-data-path"]
      ;; body)

    (with-conn [conn "my-data-path" {:likes {:db/cardinality :db.cardinality/many}}]
      ;; body)
</code></pre></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L772">view source</a></div></div><div class="public anchor" id="var-write"><h3>write</h3><div class="usage"><code>(write writer doc-ref doc-text)</code></div><div class="doc"><div class="markdown"><p>Write a document to search index.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/core.cljc#L1428">view source</a></div></div></div></body></html>